<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STAMP Decoder</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    let example_txs = [
      '9e99825880aa7cac75629ec01de28b419f691503af2c4f51b4c8b939fd37e310', //Classic_PNG
      'c46c4e59f64cdcce78e6680079bf6ae9b4d976f07eba2797c02c4c602807b17e', //Classic_GIF
      '703a8e43fbad456480a6a0820584ded924151278a09e1b832b3e11e2299d1a3a', //Classic_SVG
      'ad891d1235b04110e6d174040de034760d1fa4c0a18437f169a1d1de34091ed3', //Classic_HTML
      '9bfd550831fd3fde30a8d168e458340256b58b1e75ad109785d7ce5beb726946', //Olga_PNG
      'c075e98ae365c809ccd2804c1487a799748399eeb9dd61708c814a5da34c9b78', //Olga_GIF
      '2825437c2d6cf4250eca8b7bbc487107cc0ee4dfcd765a2dcf33ce31c7db2f45', //Olga_webp      
      '27000ab9c75570204adc1b3a5e7820c482d99033fbb3aafb844c3a3ce8b063db', //Olga_SVG
      '8c7c8efe339d10a981ae189c7c20851f1e2f10e0e8e6792a99dbe27e32b6b6a6', //Olga_HTML
      '2cfdc5d737065aa5c5c9febde8a803b1e6ee44e47de0f2788f9dfc4d40f7ed71', //Multisig
      '55f8b7a158f0e4330e7a1db287c3495c1ee6c561262e2e8f490b8ae4c6d9fbe5', //subasset
      '9660860095ba470a9622b41ad7b594cb53dce5ade3c79cd2b226b27619bcd40a',  //Olga_SVG_gZIP
      '7c48691bf8cfafa66b1d938ada4c2c778c07a49c1a0683f969c29b94363a0fec'  //Video MP4

      
    ];

    let standards = ['stamp'];
    let p2wsh = [];

    const hash = window.location.hash;
    const queryString = hash.includes('?') ? '?' + hash.split('?')[1] : '';
    const urlParams = new URLSearchParams(queryString);
    let network = urlParams.get('network');
    let tx = urlParams.get('tx');
    if (network === 'testnet') network = 'test3';
    if (network !== 'test3') network = 'main';
    if (tx == 'random') tx = example_txs[Math.floor(Math.random() * example_txs.length)];
    if (!isNaN(tx)) tx = example_txs[parseInt(tx)];

    async function get(tx) {
      try {
        if (!/^[0-9a-fA-F]{64}$/.test(tx)) {
          throw new Error('Invalid transaction ID format');
        }
        let url = `https://api.blockcypher.com/v1/btc/${network}/txs/${tx}?instart=0&outstart=0&limit=5000`;
        let response = await fetch(url, { method: 'GET', mode: 'cors' });
        if (!response.ok) {
          let errorText = await response.text().catch(() => 'Unknown error');
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        let obj = await response.json();
        if (!obj || !obj.hash) {
          throw new Error('Invalid or empty transaction data');
        }
        while (obj.next_outputs) {
          let nextResponse = await fetch(obj.next_outputs, { method: 'GET', mode: 'cors' });
          if (!nextResponse.ok) {
            throw new Error(`HTTP ${nextResponse.status}: Failed to fetch additional outputs`);
          }
          let nextObj = await nextResponse.json();
          obj.outputs = obj.outputs.concat(nextObj.outputs);
          obj.next_outputs = nextObj.next_outputs;
        }
        console.log(`Fetched ${obj.outputs.length} outputs for tx ${tx}`);
        return obj;
      } catch (e) {
        console.error('Error fetching transaction:', e.message, { tx, network, url });
        return null;
      }
    }

    async function getRawTx(tx) {
      console.log('Fetching raw transaction data for witness scripts...');
      return null;
    }

    function getImageDimensions(base64, file_type) {
      return new Promise((resolve) => {
        try {
          if (!/^[a-zA-Z0-9+\/=]+$/.test(base64)) {
            throw new Error('Invalid base64 string');
          }
          if (file_type === 'svg+xml') {
            let xml = atob(base64);
            let parser = new DOMParser();
            let svgDoc = parser.parseFromString(xml, 'image/svg+xml');
            let svgElement = svgDoc.querySelector('svg');
            if (svgElement) {
              let width = svgElement.getAttribute('width') || 'unknown';
              let height = svgElement.getAttribute('height') || 'unknown';
              if (width && height && !isNaN(parseFloat(width)) && !isNaN(parseFloat(height))) {
                resolve(`${parseFloat(width)}x${parseFloat(height)}`);
              } else {
                resolve('unknown');
              }
            } else {
              resolve('unknown');
            }
          } else if (file_type === 'html' || file_type === 'video') {
            resolve('N/A');
          } else {
            let img = new Image();
            img.onload = function() {
              resolve(`${img.width}x${img.height}`);
            };
            img.onerror = function() {
              resolve('unknown');
            };
            img.src = `data:image/${file_type};base64,${base64}`;
          }
        } catch (e) {
          console.error('Error getting dimensions:', e);
          resolve('unknown');
        }
      });
    }

    async function get_json(tx) {
      if (typeof tx !== 'undefined' && /^[0-9a-fA-F]{64}$/.test(tx)) {
        (async () => {
          let json = await get(tx);
          if (!json) {
            document.getElementById("output").innerHTML = wl('Error', `Failed to fetch transaction data for ${tx}`);
            return;
          }
          let rawHex = await getRawTx(tx);
          decode(json, rawHex, tx);
          document.body.appendChild(notification);
          setTimeout(() => {
            notification.remove();
          }, 3000);
        })();
      } else {
        document.getElementById("output").innerHTML = wl('Error', 'Invalid transaction ID');
      }
    }

    async function decode(json, rawHex, tx) {
  try {
    json = JSON.parse(JSON.stringify(json));
    let hash = json['hash'];
    let block_height = json['block_height'] || 'unknown';
    let block_time = json['received'] ? new Date(json['received']).toLocaleString() : 'unknown';
    let from_addr = json['addresses'] && json['addresses'][0] ? json['addresses'][0] : 'unknown';
    let utxo = json['inputs'] && json['inputs'][0]['prev_hash'] ? json['inputs'][0]['prev_hash'] : 'unknown';
    let first_send_sat = json['outputs'] && json['outputs'][0]['value'] ? json['outputs'][0]['value'] : 0;
    let script_type = [];
    let script = [];
    let to_addr = [];
    p2wsh = [];

    for (const x of json['outputs'] || []) {
      let type = x['script_type'];
      script_type.push(type);
      if (type == 'pay-to-pubkey-hash') {
        script.push('0');
        to_addr.push(x['addresses'] && x['addresses'][0] ? x['addresses'][0] : 'unknown');
      } else if (type == 'pay-to-multi-pubkey-hash') {
        script.push(x['script']);
        to_addr.push('0');
      } else if (type == 'null-data') {
        script.push(x['data_hex']);
        to_addr.push('0');
      } else if (type == 'pay-to-witness-script-hash') {
        script.push(x['script']);
        p2wsh.push([x['script'], x['value']]);
      } else {
        script.push('?');
        to_addr.push('?');
      }
    }

    let recipient = script_type[0] == 'pay-to-pubkey-hash' ? to_addr[0] : '0';
    let cp_msg = '';
    let encoding = '';
    let out = '';

    for (let i = 0; i < script.length; i++) {
      if (script_type[i] == 'null-data') {
        encoding = 'op_return';
        let raw = script[i];
        raw = xcp_rc4(utxo, raw);
        if (raw.substring(0, 16) == '434e545250525459') {
          cp_msg += raw;
        } else {
          out += wl('Error', 'Invalid RC4 decryption for OP_RETURN: ' + raw.substring(0, 16));
        }
      }
      if (script_type[i] == 'pay-to-multi-pubkey-hash') {
        let raw = script[i];
        let len = 0;
        if (raw.length == 142) {
          encoding = 'op_return';
          let len_hex = raw.substring(72, 74);
          len = parseInt(hexToDec(len_hex));
          if (isNaN(len) || len < 0 || len > (raw.length - 74) / 2) {
            console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
            continue;
          }
          raw = raw.substring(74, 74 + (len * 2));
          if (!/^[0-9a-fA-F]+$/.test(raw)) {
            console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
            continue;
          }
          console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
          cp_msg += raw;
        } else if (raw.length == 210) {
          encoding = 'multisig';
          raw = raw.substring(6, 68) + raw.substring(74, 136);
          raw = xcp_rc4(utxo, raw);
          len = parseInt(hexToDec(raw.substring(0, 2)));
          if (isNaN(len) || len < 0 || len > (raw.length - 2) / 2) {
            console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
            continue;
          }
          raw = raw.substring(2, 2 + (len * 2));
          if (!/^[0-9a-fA-F]+$/.test(raw)) {
            console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
            continue;
          }
          console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
          if (cp_msg == '') {
            cp_msg += raw;
          } else {
            if (raw.substring(0, 16) == '434e545250525459') {
              raw = raw.substring(16);
            }
            cp_msg += raw;
          }
        } else {
          encoding = 'multisig (custom length)';
          raw = xcp_rc4(utxo, raw);
          len = parseInt(hexToDec(raw.substring(0, 2)));
          if (isNaN(len) || len < 0 || len > (raw.length - 2) / 2) {
            console.error(`Invalid length in multisig script ${i}: len=${len}, script=${raw}`);
            continue;
          }
          raw = raw.substring(2, 2 + (len * 2));
          if (!/^[0-9a-fA-F]+$/.test(raw)) {
            console.error(`Invalid hex data in multisig script ${i}: ${raw}`);
            continue;
          }
          console.log(`Multisig output ${i} (length ${script[i].length}): len=${len}, raw=${raw}`);
          if (cp_msg == '') {
            cp_msg += raw;
          } else {
            if (raw.substring(0, 16) == '434e545250525459') {
              raw = raw.substring(16);
            }
            cp_msg += raw;
          }
        }
      }
    }
    console.log(`Final cp_msg: ${cp_msg}`);

    out += '<div class="section-title">BITCOIN DATA</div>';
    out += wl('Tx ID', hash);
    out += wl('Block #', block_height);
    out += wl('Block Time', block_time);
    out += wl('Address', from_addr);
    out += '<div class="section-title">CP/STAMP DATA</div>';

    out += `<div class="output-row"><span class="output-label">Raw (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(cp_msg, 96)}</pre></details></span></div>`;
    out += `<div class="output-row"><span class="output-label">Raw (ascii)</span><span class="output-value"><details><summary>ASCII: (click to expand/collapse)</summary><pre class="base64-content">${chunk(hex2a(cp_msg), 96)}</pre></details></span></div>`;

    if (cp_msg.substring(0, 16) != '434e545250525459') {
      out += wl('Error', 'No valid CP/Stamp data found');
      if (p2wsh.length > 0) {
        console.log('P2WSH outputs found; attempting OLGA STAMP decoding');
        out += await print_standard('stamp:', tx, 'A' + BigInt('0x' + cp_msg.substring(2, 18)).toString(10), cp_msg);
      } else {
        out += wl('Error', 'No valid CP/Stamp data or P2WSH outputs found');
      }
      document.getElementById("output").innerHTML = out;
      attachPendingVideoEventListeners(); // Add here
      output2(hash);
      return;
    }

    cp_msg = cp_msg.substring(16);
    console.log(`After removing CNTRPRTY: cp_msg=${cp_msg}`);
    if (cp_msg.length < 36) {
      out += wl('Error', `Invalid CP/Stamp message length: ${cp_msg.length} (expected at least 36)`);
      document.getElementById("output").innerHTML = out;
      attachPendingVideoEventListeners(); // Add here
      output2(hash);
      return;
    }

    let id_hex = cp_msg.substring(0, 2);
    let id = parseInt(id_hex, 16);
    console.log(`id_hex=${id_hex}, id=${id}`);
    cp_msg = cp_msg.substring(2);

    out += wl('Message ID (hex)', id_hex);
    out += wl('Message ID', id);

    let blockHeightNum = block_height === 'unknown' ? 0 : parseInt(block_height);

    if (id == 20 && blockHeightNum < 753500) {
      out += wl('Type', 'Issuance');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      out += wl('Asset', 'A' + asset);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      let descr_hex = cp_msg;
      let descr = hex2a(descr_hex);
      if (descr.toLowerCase().startsWith('stamp:')) {
        out += await print_standard('stamp:', tx, 'A' + asset, descr);
      } else {
        out += wl('Error', 'Expected Classic Stamp description starting with "stamp:"');
      }

    } else if (id == 21 && blockHeightNum < 753500) {
      out += wl('Type', 'Issuance');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let len_subasset_hex = cp_msg.substring(0, 2);
      let len_subasset = parseInt(len_subasset_hex, 16);
      cp_msg = cp_msg.substring(2);
      if (cp_msg.length < len_subasset * 2) {
        out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let subasset_hex = cp_msg.substring(0, len_subasset * 2);
      let subasset = hex_to_subasset(subasset_hex);
      cp_msg = cp_msg.substring(len_subasset * 2);

      let descr_hex = cp_msg;
      let descr = hex2a(descr_hex);

      out += wl('Asset', 'A' + asset);
      out += wl('Subasset', subasset);
      out += wl('Subasset (hex)', subasset_hex);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      if (descr.toLowerCase().startsWith('stamp:')) {
        out += await print_standard('stamp:', tx, 'A' + asset, descr);
      } else {
        out += wl('Description', descr);
        out += wl('Description (hex)', descr_hex);
      }

    } else if (id == 20 && blockHeightNum >= 753500) {
      out += wl('Type', 'Issuance');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      out += wl('Asset', 'A' + asset);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      out += await print_standard('stamp:', tx, 'A' + asset, p2wsh.length > 0 ? '' : cp_msg);

    } else if (id == 22 && blockHeightNum >= 819300) {
      out += wl('Type', 'Issuance');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      out += wl('Asset', 'A' + asset);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      out += await print_standard('stamp:', tx, 'A' + asset, p2wsh.length > 0 ? '' : cp_msg);

    } else if (id == 21 && blockHeightNum >= 753500) {
      out += wl('Type', 'Issuance (Subasset Olga)');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let len_subasset_hex = cp_msg.substring(0, 2);
      let len_subasset = parseInt(len_subasset_hex, 16);
      cp_msg = cp_msg.substring(2);
      if (cp_msg.length < len_subasset * 2) {
        out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let subasset_hex = cp_msg.substring(0, len_subasset * 2);
      let subasset = hex_to_subasset(subasset_hex);
      cp_msg = cp_msg.substring(len_subasset * 2);

      let descr_hex = cp_msg;
      let descr = hex2a(descr_hex);

      out += wl('Asset', 'A' + asset);
      out += wl('Subasset', subasset);
      out += wl('Subasset (hex)', subasset_hex);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      if (descr.toLowerCase().startsWith('stamp:')) {
        out += await print_standard('stamp:', tx, 'A' + asset, descr);
      } else {
        out += wl('Description', descr);
        out += wl('Description (hex)', descr_hex);
      }

    } else if (id == 23 && blockHeightNum >= 819300) {
      out += wl('Type', 'Issuance (Subasset Olga)');
      let asset_hex = cp_msg.substring(0, 16);
      let asset = BigInt('0x' + asset_hex).toString(10);
      cp_msg = cp_msg.substring(16);

      let q_hex = cp_msg.substring(0, 16);
      if (!/^[0-9a-fA-F]{16}$/.test(q_hex)) {
        console.error(`Invalid q_hex format: ${q_hex}`);
        out += wl('Error', `Invalid issuance quantity format: ${q_hex}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let q = Number(BigInt('0x' + q_hex));
      cp_msg = cp_msg.substring(16);

      let div_hex = cp_msg.substring(0, 2);
      let div = parseInt(div_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let lock_hex = cp_msg.substring(0, 2);
      let lock = parseInt(lock_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let reset_hex = cp_msg.substring(0, 2);
      let reset = parseInt(reset_hex, 16) ? true : false;
      cp_msg = cp_msg.substring(2);

      let len_subasset_hex = cp_msg.substring(0, 2);
      let len_subasset = parseInt(len_subasset_hex, 16);
      cp_msg = cp_msg.substring(2);
      if (cp_msg.length < len_subasset * 2) {
        out += wl('Error', `Invalid subasset length: ${len_subasset}, remaining cp_msg length: ${cp_msg.length}`);
        document.getElementById("output").innerHTML = out;
        attachPendingVideoEventListeners(); // Add here
        output2(hash);
        return;
      }
      let subasset_hex = cp_msg.substring(0, len_subasset * 2);
      let subasset = hex_to_subasset(subasset_hex);
      cp_msg = cp_msg.substring(len_subasset * 2);

      let descr_hex = cp_msg;
      let descr = hex2a(descr_hex);

      out += wl('Asset', 'A' + asset);
      out += wl('Subasset', subasset);
      out += wl('Subasset (hex)', subasset_hex);
      out += wl('Issuance', q);
      out += wl('Divisible', div);
      out += wl('Lock', lock);
      out += wl('Reset', reset);

      if (descr.toLowerCase().startsWith('stamp:')) {
        out += await print_standard('stamp:', tx, 'A' + asset, descr);
      } else {
        out += wl('Description', descr);
        out += wl('Description (hex)', descr_hex);
      }

    } else {
      out += wl('Error', 'Not a valid Issuance or Subasset transaction! Message ID: ' + id + ', Block Height: ' + block_height);
    }

    if (recipient != '0') {
      out += wl('Transfer To', recipient);
      out += wl('Dust (sat)', first_send_sat);
      out += wl('Dust (btc)', (first_send_sat / 100000000).toFixed(8));
    }

    document.getElementById("output").innerHTML = out;
    attachPendingVideoEventListeners(); // Add here
    output2(hash);
  } catch (e) {
    console.error('Error in decode:', e);
    document.getElementById("output").innerHTML = wl('Error', 'Failed to decode transaction: ' + e.message);
    attachPendingVideoEventListeners(); // Add here
  }
}
    function output2(tx) {
      let out = '<br>';
      out += 'View on: <br>';
      out += '<a href="https://stampchain.io/api/v2/stamps/' + tx + '">Stampchain.io</a> ';
      out += '<a href="https://live.blockcypher.com/btc/tx/' + tx + '/">BlockCypher</a> ';
      out += '<a href="https://www.blockchain.com/btc/tx/' + tx + '">Blockchain.com</a> ';
      out += '<a href="https://blockstream.info/tx/' + tx + '">Blockstream</a>';
      document.getElementById("output2").innerHTML = out;
    }

    function wl(title, info) {
      return `<div class="output-row"><span class="output-label">${title}</span><span class="output-value">${chunk(String(info), '<br>', 96)}</span></div>`;
    }

    function chunk(str, sep, n) {
      str = String(str);
      var ret = [];
      for (var i = 0, len = str.length; i < len; i += n) {
        ret.push(str.substr(i, n));
      }
      return ret.join(sep);
    }

    function hex2a(hexx) {
      if (!/^[0-9a-fA-F]+$/.test(hexx)) {
        console.error(`Invalid hex in hex2a: ${hexx.slice(0, 50)}...`);
        return '';
      }
      var hex = hexx.toString();
      var str = '';
      for (var i = 0; i < hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return str;
    }

    function xcp_rc4(key, datachunk) {
      return bin2hex(rc4(hex2bin(key), hex2bin(datachunk)));
    }

    function hex2bin(hex) {
      var bytes = [];
      for (var i = 0; i < hex.length - 1; i += 2) {
        var ch = parseInt(hex.substr(i, 2), 16);
        bytes.push(ch);
      }
      return String.fromCharCode.apply(String, bytes);
    }

    function bin2hex(s) {
      var o = '';
      for (var i = 0, l = s.length; i < l; i++) {
        var n = s.charCodeAt(i).toString(16);
        o += n.length < 2 ? '0' + n : n;
      }
      return o;
    }

    function rc4(key, str) {
      var s = [], j = 0, x, res = '';
      for (var i = 0; i < 256; i++) {
        s[i] = i;
      }
      for (i = 0; i < 256; i++) {
        j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;
        x = s[i];
        s[i] = s[j];
        s[j] = x;
      }
      i = 0;
      j = 0;
      for (var y = 0; y < str.length; y++) {
        i = (i + 1) % 256;
        j = (j + s[i]) % 256;
        x = s[i];
        s[i] = s[j];
        s[j] = x;
        res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);
      }
      return res;
    }

    function hexToDec(s) {
      var digits = [0], carry;
      for (var i = 0; i < s.length; i += 1) {
        carry = parseInt(s.charAt(i), 16);
        for (var j = 0; j < digits.length; j += 1) {
          digits[j] = digits[j] * 16 + carry;
          carry = digits[j] / 10 | 0;
          digits[j] %= 10;
        }
        while (carry > 0) {
          digits.push(carry % 10);
          carry = carry / 10 | 0;
        }
      }
      return digits.reverse().join('');
    }

    function asset_name(id) {
      if (id == 0) return 'BTC';
      if (id == 1) return 'XCP';
      if (id >= 95428956661682177) return 'numerical or sub-asset';
      if (id > 9007199254740991) return 'max int error';
      let b26_digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let n = id;
      let name = '';
      do {
        let mod = n % 26;
        name = b26_digits[mod] + name;
        n -= mod;
        n /= 26;
      } while (n > 0);
      return name;
    }

    function hex_to_subasset(hex) {
      const SUBASSET_DIGITS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_@!';
      let integer = BigInt('0x' + hex);
      let ret = '';
      while (integer != 0n) {
        ret = SUBASSET_DIGITS[(integer % 68n) - 1n] + ret;
        integer = integer / 68n;
      }
      return ret;
    }

   async function print_standard(descr, tx, assetOrCPID, cp_msg) {
  let out = '';
  let isClassic = false;

  if (descr.toLowerCase().startsWith('stamp:') && /^[a-zA-Z0-9+\/=]+$/.test(descr.substr(6))) {
    isClassic = true;
    out += wl('Standard', 'STAMP (Classic)');
    let image = descr.slice(6).replace(/\s/g, '');
    let paddingNeeded = (4 - (image.length % 4)) % 4;
    image += '='.repeat(paddingNeeded);
    console.log(`Classic stamp base64 (cleaned): ${image.slice(0, 50)}...`);
    if (/^[a-zA-Z0-9+\/=]+$/.test(image) && image.length % 4 === 0) {
      let file_type = '';
      let isGzip = image.startsWith('H4sI');
      let processedImage = image;
      try {
        if (isGzip) {
          console.log('Detected gZIP-compressed Base64 in Classic stamp');
          let decoded;
          try {
            decoded = atob(image);
            console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
          } catch (e) {
            out += wl('Error', 'Failed to decode base64 for Classic STAMP: ' + e.message);
            console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
            return out;
          }
          try {
            let binary = new Uint8Array(decoded.length);
            for (let i = 0; i < decoded.length; i++) {
              binary[i] = decoded.charCodeAt(i);
            }
            let decompressed = pako.ungzip(binary, { to: 'string' });
            processedImage = btoa(decompressed);
            console.log(`Decompressed gZIP base64: ${processedImage.slice(0, 50)}...`);
          } catch (e) {
            out += wl('Error', 'Failed to decompress gZIP data for Classic STAMP: ' + e.message);
            console.error(`gZIP decompression error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
            return out;
          }
        }
        let decoded;
        try {
          decoded = atob(processedImage);
          console.log(`Decoded Classic stamp starts with: ${decoded.slice(0, 50)}...`);
        } catch (e) {
          out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
          console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
          return out;
        }
        if (processedImage.slice(0, 6) === 'R0lGOD') {
          file_type = 'gif';
          console.log('Detected GIF in Classic stamp');
        } else if (processedImage.slice(0, 6) === 'iVBORw') {
          file_type = 'png';
          console.log('Detected PNG in Classic stamp');
        } else if (processedImage.slice(0, 4) === '/9j/') {
          file_type = 'jpeg';
          console.log('Detected JPEG in Classic stamp');
        } else if (processedImage.slice(0, 5) === 'PHN2Z' || processedImage.slice(0, 5) === 'PD94b') {
          file_type = 'svg+xml';
          console.log('Detected SVG in Classic stamp');
        } else if (processedImage.slice(0, 5) === 'UklGR') {
          file_type = 'webp';
          console.log('Detected WebP in Classic stamp');
        } else {
          file_type = 'html';
          console.log('Detected HTML in Classic stamp (default)');
        }
        
        out += wl('Compression', isGzip ? 'gZIP' : 'None');
        if (file_type === 'html') {
          try {
            let htmlContent = atob(processedImage);
            let parser = new DOMParser();
            let doc = parser.parseFromString(htmlContent, 'text/html');
            let video = doc.querySelector('video');
            if (video && video.src) {
              file_type = 'video';
              out += wl('MIME Type', 'video/mp4');
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
              let dimensions = await getImageDimensions(processedImage, file_type);
              out += wl('Dimensions', dimensions);
              let videoSrc = encodeURI(video.src);
              console.log('Video source:', videoSrc);
              out += `<video id="stamp-video-${tx}" class="stamp-video" controls preload="metadata" muted playsinline src="${videoSrc}"></video><br>`;
              out += `<div class="output-row"><span class="output-label">Note</span><span class="output-value">Tap the video to start playback or adjust volume. If playback fails, ensure the file is valid.</span></div>`;
              window.pendingVideoEventListeners = window.pendingVideoEventListeners || [];
              window.pendingVideoEventListeners.push(tx);
            } else {
              out += wl('MIME Type', 'text/html');
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
              let dimensions = await getImageDimensions(processedImage, file_type);
              out += wl('Dimensions', dimensions);
              out += `<iframe class="stamp-iframe" sandbox="allow-scripts" src="data:text/html;base64,${processedImage}"></iframe><br>`;
            }
          } catch (e) {
            out += wl('Error', 'Failed to parse HTML content: ' + e.message);
            console.error(`HTML parsing error: ${e.message}`);
          }
        } else {
          out += wl('MIME Type', `image/${file_type}`);
          out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
          out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
          let dimensions = await getImageDimensions(processedImage, file_type);
          out += wl('Dimensions', dimensions);
          out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedImage}" /><br>`;
        }
      } catch (e) {
        out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
        console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
      }
    } else {
      out += wl('Error', 'Invalid base64 format for Classic STAMP');
      console.error(`Invalid base64 format: ${image.slice(0, 50)}...`);
    }
    return out; // Exit after processing Classic STAMP
  }

  // Olga STAMP processing
  out += wl('Standard', 'STAMP (OLGA)');
  let hex = '';
  let dust = 0;
  if (p2wsh.length === 0) {
    console.log(`No P2WSH outputs; using multisig data for OLGA STAMP: cp_msg=${cp_msg}`);
    if (!cp_msg || cp_msg.length <= 4) {
      out += wl('Error', 'No valid multisig data for OLGA STAMP');
      console.error(`Invalid or missing cp_msg: ${cp_msg}`);
      return out;
    }
    console.log(`Processing multisig data: cp_msg=${cp_msg}`);
    hex = cp_msg;
    if (!/^[0-9a-fA-F]+$/.test(hex)) {
      out += wl('Error', 'Invalid hex format in multisig data for OLGA STAMP');
      console.error(`Invalid hex: ${hex}`);
      return out;
    }
    let file_size_hex = hex.slice(0, 4);
    let file_size = parseInt(file_size_hex, 16);
    console.log(`File size hex=${file_size_hex}, file_size=${file_size}, hex length=${hex.length}`);
    if (isNaN(file_size) || file_size <= 0 || hex.length < file_size * 2 + 4) {
      let descr = hex2a(hex);
      descr = decodeURIComponent(escape(descr));
      console.log(`Invalid file size, attempting Classic stamp parsing: descr=${descr}`);
      if (descr.toLowerCase().startsWith('stamp:') && /^[a-zA-Z0-9+\/=]+$/.test(descr.substr(6))) {
        isClassic = true;
        out = ''; // Clear previous Olga output
        out += wl('Standard', 'STAMP (Classic)');
        let image = descr.slice(6).replace(/\s/g, '');
        let paddingNeeded = (4 - (image.length % 4)) % 4;
        image += '='.repeat(paddingNeeded);
        console.log(`Classic stamp base64 (cleaned): ${image.slice(0, 50)}...`);
        if (/^[a-zA-Z0-9+\/=]+$/.test(image) && image.length % 4 === 0) {
          let file_type = '';
          let isGzip = image.startsWith('H4sI');
          let processedImage = image;
          try {
            if (isGzip) {
              console.log('Detected gZIP-compressed Base64 in Classic fallback');
              let decoded;
              try {
                decoded = atob(image);
              } catch (e) {
                out += wl('Error', 'Failed to decode base64 for Classic STAMP: ' + e.message);
                console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                return out;
              }
              try {
                let binary = new Uint8Array(decoded.length);
                for (let i = 0; i < decoded.length; i++) {
                  binary[i] = decoded.charCodeAt(i);
                }
                let decompressed = pako.ungzip(binary, { to: 'string' });
                processedImage = btoa(decompressed);
                console.log(`Decompressed gZIP base64: ${processedImage.slice(0, 50)}...`);
              } catch (e) {
                out += wl('Error', 'Failed to decompress gZIP data for Classic STAMP: ' + e.message);
                console.error(`gZIP decompression error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
                return out;
              }
            }
            let decoded;
            try {
              decoded = atob(processedImage);
              console.log(`Decoded Classic stamp starts with: ${decoded.slice(0, 50)}...`);
            } catch (e) {
              out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
              console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
              return out;
            }
            if (processedImage.slice(0, 6) === 'R0lGOD') {
              file_type = 'gif';
              console.log('Detected GIF in Classic stamp');
            } else if (processedImage.slice(0, 6) === 'iVBORw') {
              file_type = 'png';
              console.log('Detected PNG in Classic stamp');
            } else if (processedImage.slice(0, 4) === '/9j/') {
              file_type = 'jpeg';
              console.log('Detected JPEG in Classic stamp');
            } else if (processedImage.slice(0, 5) === 'PHN2Z' || processedImage.slice(0, 5) === 'PD94b') {
              file_type = 'svg+xml';
              console.log('Detected SVG in Classic stamp');
            } else if (processedImage.slice(0, 5) === 'UklGR') {
              file_type = 'webp';
              console.log('Detected WebP in Classic stamp');
            } else {
              file_type = 'html';
              console.log('Detected HTML in Classic stamp (default)');
            }
            
            out += wl('Compression', isGzip ? 'gZIP' : 'None');
            if (file_type === 'html') {
              try {
                let htmlContent = atob(processedImage);
                let parser = new DOMParser();
                let doc = parser.parseFromString(htmlContent, 'text/html');
                let video = doc.querySelector('video');
                if (video && video.src) {
                  file_type = 'video';
                  out += wl('MIME Type', 'video/mp4');
                  out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
                  out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
                  let dimensions = await getImageDimensions(processedImage, file_type);
                  out += wl('Dimensions', dimensions);
                  let videoSrc = encodeURI(video.src);
                  console.log('Video source:', videoSrc);
                  out += `<video id="stamp-video-${tx}" class="stamp-video" controls preload="metadata" muted playsinline src="${videoSrc}"></video><br>`;
                  out += `<div class="output-row"><span class="output-label">Note</span><span class="output-value">Tap the video to start playback or adjust volume. If playback fails, ensure the file is valid.</span></div>`;
                  window.pendingVideoEventListeners = window.pendingVideoEventListeners || [];
                  window.pendingVideoEventListeners.push(tx);
                } else {
                  out += wl('MIME Type', 'text/html');
                  out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
                  out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
                  let dimensions = await getImageDimensions(processedImage, file_type);
                  out += wl('Dimensions', dimensions);
                  out += `<iframe class="stamp-iframe" sandbox="allow-scripts" src="data:text/html;base64,${processedImage}"></iframe><br>`;
                }
              } catch (e) {
                out += wl('Error', 'Failed to parse HTML content: ' + e.message);
                console.error(`HTML parsing error: ${e.message}`);
              }
            } else {
              out += wl('MIME Type', `image/${file_type}`);
              out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${image}</pre></details></span></div>`;
              out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + image), 96)}</pre></details></span></div>`;
              let dimensions = await getImageDimensions(processedImage, file_type);
              out += wl('Dimensions', dimensions);
              out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedImage}" /><br>`;
            }
          } catch (e) {
            out += wl('Error', 'Invalid base64 data for Classic STAMP: ' + e.message);
            console.error(`Base64 decode error in Classic stamp: ${e.message}, image=${image.slice(0, 50)}...`);
          }
        } else {
          out += wl('Error', 'Invalid base64 format for Classic STAMP');
          console.error(`Invalid base64 format: ${image.slice(0, 50)}...`);
        }
        return out; // Exit after processing Classic STAMP in fallback
      } else {
        out += wl('Error', `Invalid or insufficient multisig data for file size: file_size=${file_size}, hex length=${hex.length}, required=${file_size * 2 + 4}`);
        console.error(`Invalid file size: ${file_size}, hex=${hex}`);
        return out;
      }
    }
    let file = hex.slice(4, 4 + file_size * 2);
    console.log(`Extracted file data: file=${file}`);
    let hexPairs = file.match(/\w{2}/g);
    if (!hexPairs) {
      out += wl('Error', 'Invalid multisig data format for OLGA STAMP');
      console.error(`Invalid file data: ${file}`);
      return out;
    }
    let base64 = '';
    try {
      base64 = btoa(hexPairs.map(y => String.fromCharCode(parseInt(y, 16))).join(''));
      console.log(`Olga stamp base64: ${base64.slice(0, 50)}...`);
    } catch (e) {
      out += wl('Error', 'Failed to convert multisig data to base64: ' + e.message);
      console.error(`Base64 conversion error: ${e.message}, file=${file}`);
      return out;
    }
    if (!base64 || base64 === '') {
      out += wl('Error', 'Base64 data is undefined or empty for OLGA STAMP');
      console.error(`Base64 is undefined or empty: file=${file}`);
      return out;
    }
    let file_type = '';
    let isGzip = base64.startsWith('H4sI');
    let processedBase64 = base64;
    try {
      if (isGzip) {
        console.log('Detected gZIP-compressed Base64 in Olga stamp');
        let decoded;
        try {
          decoded = atob(base64);
          console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
        } catch (e) {
          out += wl('Error', 'Failed to decode base64 for OLGA STAMP: ' + e.message);
          console.error(`Base64 decode error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
          return out;
        }
        try {
          let binary = new Uint8Array(decoded.length);
          for (let i = 0; i < decoded.length; i++) {
            binary[i] = decoded.charCodeAt(i);
          }
          let decompressed = pako.ungzip(binary, { to: 'string' });
          processedBase64 = btoa(decompressed);
          console.log(`Decompressed gZIP base64: ${processedBase64.slice(0, 50)}...`);
        } catch (e) {
          out += wl('Error', 'Failed to decompress gZIP data for OLGA STAMP: ' + e.message);
          console.error(`gZIP decompression error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
          return out;
        }
      }
      let decoded;
      try {
        decoded = atob(processedBase64);
        console.log(`Decoded Olga stamp starts with: ${decoded.slice(0, 50)}...`);
      } catch (e) {
        out += wl('Error', 'Invalid base64 data for OLGA STAMP: ' + e.message);
        console.error(`Base64 decode error in Olga stamp: ${e.message}, base64=${base64.slice(0, 50)}...`);
        return out;
      }
      if (processedBase64.slice(0, 6) === 'R0lGOD') {
        file_type = 'gif';
        console.log('Detected GIF in Olga stamp');
      } else if (processedBase64.slice(0, 6) === 'iVBORw') {
        file_type = 'png';
        console.log('Detected PNG in Olga stamp');
      } else if (processedBase64.slice(0, 4) === '/9j/') {
        file_type = 'jpeg';
        console.log('Detected JPEG in Olga stamp');
      } else if (processedBase64.slice(0, 5) === 'PHN2Z' || processedBase64.slice(0, 5) === 'PD94b') {
        file_type = 'svg+xml';
        console.log('Detected SVG in Olga stamp');
      } else if (processedBase64.slice(0, 5) === 'UklGR') {
        file_type = 'webp';
        console.log('Detected WebP in Olga stamp');
      } else {
        file_type = 'html';
        console.log('Detected HTML in Olga stamp (default)');
      }

      out += wl('File size (bytes)', file_size);
      out += wl('Burned (sat)', dust);
      out += wl('Burned (btc)', (dust / 100000000).toFixed(8));
      out += wl('Asset', assetOrCPID);
      out += wl('Compression', isGzip ? 'gZIP' : 'None');
      if (file_type === 'html') {
        try {
          let htmlContent = atob(processedBase64);
          let parser = new DOMParser();
          let doc = parser.parseFromString(htmlContent, 'text/html');
          let video = doc.querySelector('video');
          if (video && video.src) {
            file_type = 'video';
            out += wl('MIME Type', 'video/mp4');
            out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
            out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
            let dimensions = await getImageDimensions(processedBase64, file_type);
            out += wl('Dimensions', dimensions);
            let videoSrc = encodeURI(video.src);
            console.log('Video source:', videoSrc);
            out += `<video id="stamp-video-${tx}" class="stamp-video" controls preload="metadata" muted playsinline src="${videoSrc}"></video><br>`;
            out += `<div class="output-row"><span class="output-label">Note</span><span class="output-value">Tap the video to start playback or adjust volume. If playback fails, ensure the file is valid.</span></div>`;
            window.pendingVideoEventListeners = window.pendingVideoEventListeners || [];
            window.pendingVideoEventListeners.push(tx);
          } else {
            out += wl('MIME Type', 'text/html');
            out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
            out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
            let dimensions = await getImageDimensions(processedBase64, file_type);
            out += wl('Dimensions', dimensions);
            out += `<iframe class="stamp-iframe" sandbox="allow-scripts" src="data:text/html;base64,${processedBase64}"></iframe><br>`;
          }
        } catch (e) {
          out += wl('Error', 'Failed to parse HTML content: ' + e.message);
          console.error(`HTML parsing error: ${e.message}`);
        }
      } else {
        out += wl('MIME Type', `image/${file_type}`);
        out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
        out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
        let dimensions = await getImageDimensions(processedBase64, file_type);
        out += wl('Dimensions', dimensions);
        out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedBase64}" /><br>`;
      }
    } catch (e) {
      out += wl('Error', 'Invalid base64 data for OLGA STAMP: ' + e.message);
      console.error(`Base64 validation error: ${e.message}, base64=${base64.slice(0, 50)}...`);
    }
  } else {
    let hex = '';
    let dust = 0;
    for (let i = 0; i < p2wsh.length; i++) {
      hex += p2wsh[i][0].slice(4);
      dust += p2wsh[i][1];
    }
    let file_size_hex = hex.slice(0, 4);
    let file_size = parseInt(file_size_hex, 16);
    console.log(`P2WSH file size hex=${file_size_hex}, file_size=${file_size}, hex length=${hex.length}`);
    if (isNaN(file_size) || file_size <= 0 || hex.length < file_size * 2 + 4) {
      out += wl('Error', `Invalid or insufficient P2WSH data for file size: file_size=${file_size}, hex length=${hex.length}, required=${file_size * 2 + 4}`);
      console.error(`Invalid P2WSH file size: ${file_size}, hex=${hex}`);
      return out;
    }
    let file = hex.slice(4, 4 + file_size * 2);
    console.log(`P2WSH file data: file=${file}`);
    let hexPairs = file.match(/\w{2}/g);
    if (!hexPairs) {
      out += wl('Error', 'Invalid P2WSH data format for OLGA STAMP');
      console.error(`Invalid P2WSH file data: ${file}`);
      return out;
    }
    let base64 = '';
    try {
      base64 = btoa(hexPairs.map(y => String.fromCharCode(parseInt(y, 16))).join(''));
      console.log(`P2WSH base64: ${base64.slice(0, 50)}...`);
    } catch (e) {
      out += wl('Error', 'Failed to convert P2WSH data to base64: ' + e.message);
      console.error(`P2WSH base64 conversion error: ${e.message}, file=${file}`);
      return out;
    }
    if (!base64 || base64 === '') {
      out += wl('Error', 'Base64 data is undefined or empty for OLGA STAMP');
      console.error(`Base64 is undefined or empty: file=${file}`);
      return out;
    }
    let file_type = '';
    let isGzip = base64.startsWith('H4sI');
    let processedBase64 = base64;
    try {
      if (isGzip) {
        console.log('Detected gZIP-compressed Base64 in P2WSH');
        let decoded;
        try {
          decoded = atob(base64);
          console.log(`Base64 decoded: ${decoded.slice(0, 50)}...`);
        } catch (e) {
          out += wl('Error', 'Failed to decode base64 for OLGA STAMP (P2WSH): ' + e.message);
          console.error(`Base64 decode error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
          return out;
        }
        try {
          let binary = new Uint8Array(decoded.length);
          for (let i = 0; i < decoded.length; i++) {
            binary[i] = decoded.charCodeAt(i);
          }
          let decompressed = pako.ungzip(binary, { to: 'string' });
          processedBase64 = btoa(decompressed);
          console.log(`Decompressed gZIP base64: ${processedBase64.slice(0, 50)}...`);
        } catch (e) {
          out += wl('Error', 'Failed to decompress gZIP data for OLGA STAMP (P2WSH): ' + e.message);
          console.error(`gZIP decompression error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
          return out;
        }
      }
      let decoded;
      try {
        decoded = atob(processedBase64);
        console.log(`Decoded P2WSH starts with: ${decoded.slice(0, 50)}...`);
      } catch (e) {
        out += wl('Error', 'Invalid base64 data for OLGA STAMP (P2WSH): ' + e.message);
        console.error(`Base64 decode error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
        return out;
      }
      if (processedBase64.slice(0, 6) === 'R0lGOD') {
        file_type = 'gif';
        console.log('Detected GIF in P2WSH');
      } else if (processedBase64.slice(0, 6) === 'iVBORw') {
        file_type = 'png';
        console.log('Detected PNG in P2WSH');
      } else if (processedBase64.slice(0, 4) === '/9j/') {
        file_type = 'jpeg';
        console.log('Detected JPEG in P2WSH');
      } else if (processedBase64.slice(0, 5) === 'PHN2Z' || processedBase64.slice(0, 5) === 'PD94b') {
        file_type = 'svg+xml';
        console.log('Detected SVG in P2WSH');
      } else if (processedBase64.slice(0, 5) === 'UklGR') {
        file_type = 'webp';
        console.log('Detected WebP in P2WSH');
      } else {
        file_type = 'html';
        console.log('Detected HTML in P2WSH (default)');
      }

      out += wl('File size (byte)', file_size);
      out += wl('Burned (sat)', dust);
      out += wl('Burned (btc)', (dust / 100000000).toFixed(8));
      out += wl('Asset', assetOrCPID);
      out += wl('Compression', isGzip ? 'gZIP' : 'None');
      if (file_type === 'html') {
        try {
          let htmlContent = atob(processedBase64);
          let parser = new DOMParser();
          let doc = parser.parseFromString(htmlContent, 'text/html');
          let video = doc.querySelector('video');
          if (video && video.src) {
            file_type = 'video';
            out += wl('MIME Type', 'video/mp4');
            out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
            out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
            let dimensions = await getImageDimensions(processedBase64, file_type);
            out += wl('Dimensions', dimensions);
            let videoSrc = encodeURI(video.src);
            console.log('Video source:', videoSrc);
            out += `<video id="stamp-video-${tx}" class="stamp-video" controls preload="metadata" muted playsinline src="${videoSrc}"></video><br>`;
            out += `<div class="output-row"><span class="output-label">Note</span><span class="output-value">Tap the video to start playback or adjust volume. If playback fails, ensure the file is valid.</span></div>`;
            window.pendingVideoEventListeners = window.pendingVideoEventListeners || [];
            window.pendingVideoEventListeners.push(tx);
          } else {
            out += wl('MIME Type', 'text/html');
            out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
            out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
            let dimensions = await getImageDimensions(processedBase64, file_type);
            out += wl('Dimensions', dimensions);
            out += `<iframe class="stamp-iframe" sandbox="allow-scripts" src="data:text/html;base64,${processedBase64}"></iframe><br>`;
          }
        } catch (e) {
          out += wl('Error', 'Failed to parse HTML content: ' + e.message);
          console.error(`HTML parsing error: ${e.message}`);
        }
      } else {
        out += wl('MIME Type', `image/${file_type}`);
        out += `<div class="output-row"><span class="output-label">Description</span><span class="output-value"><details><summary>Base64: (click to expand/collapse)</summary><pre class="base64-content">STAMP:${base64}</pre></details></span></div>`;
        out += `<div class="output-row"><span class="output-label">Description (hex)</span><span class="output-value"><details><summary>Hex: (click to expand/collapse)</summary><pre class="base64-content">${chunk(bin2hex('STAMP:' + base64), 96)}</pre></details></span></div>`;
        let dimensions = await getImageDimensions(processedBase64, file_type);
        out += wl('Dimensions', dimensions);
        out += `<img class="stamp-image" src="data:image/${file_type};base64,${processedBase64}" /><br>`;
      }
    } catch (e) {
      out += wl('Error', 'Invalid base64 data for OLGA STAMP (P2WSH): ' + e.message);
      console.error(`Base64 validation error in P2WSH: ${e.message}, base64=${base64.slice(0, 50)}...`);
    }
  }
  return out;
}

function attachPendingVideoEventListeners() {
  if (window.pendingVideoEventListeners && window.pendingVideoEventListeners.length > 0) {
    const attachListeners = () => {
      window.pendingVideoEventListeners.forEach(tx => {
        const video = document.getElementById(`stamp-video-${tx}`);
        if (video) {
          console.log(`Attaching touchstart listener to video: ${tx}`);
          video.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (video.paused) {
              video.play().catch(err => console.error(`Video play error for ${tx}:`, err));
            } else {
              video.pause();
            }
 }, { passive: false });
video.addEventListener('click', (e) => {
  e.preventDefault();
  if (video.paused) {
    video.play().catch(err => console.error(`Video play error for ${tx}:`, err));
  } else {
    video.pause();
  }
}, { passive: false });
        } else {
          console.error(`Video element not found for ${tx}`);
        }
      });
      window.pendingVideoEventListeners = [];
    };
    // Retry after a short delay if DOM isn't ready
    if (document.getElementById(`stamp-video-${window.pendingVideoEventListeners[0]}`)) {
      attachListeners();
    } else {
      setTimeout(attachListeners, 100);
    }
  }
}
    
    window.onload = function() {
      if (tx) {
        document.getElementById('txid').value = tx;
        get_json(tx);
      }
    };
    
    function toggleDarkMode() {
      const isDark = document.body.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
      document.getElementById('theme-toggle').textContent = isDark ? ' Light Mode' : ' Dark Mode';
    }

    window.onload = function() {
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-toggle').textContent = ' Light Mode';
      }
      if (tx) {
        document.getElementById('txid').value = tx;
        get_json(tx);
      }
    };
    
  </script>

  <style>
body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
}
body.dark-mode {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }

    body.dark-mode #content {
      background-color: #2d2d2d;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.7);
    }

    body.dark-mode #txid {
      background-color: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    body.dark-mode #txid:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
    }

    body.dark-mode input[type=submit] {
      background-color: #60a5fa;
    }

    body.dark-mode input[type=submit]:hover {
      background-color: #3b82f6;
    }

    body.dark-mode .output-label {
      color: #e0e0e0;
    }

    body.dark-mode .output-value {
      color: #b0b0b0;
    }

    body.dark-mode .section-title {
      color: #e0e0e0;
      border-left-color: #60a5fa;
    }

    body.dark-mode pre {
      background-color: #3a3a3a;
      border-color: #555;
      color: #e0e0e0;
    }

    body.dark-mode #output2 a {
      color: #60a5fa;
    }

    body.dark-mode #output2 a:hover {
      color: #3b82f6;
    }

    body.dark-mode #footer {
      color: #9ca3af;
    }

    #theme-toggle {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 0.5rem;
      font-size: 0.5rem;
      background-color: grey;
      color: #ffffff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    #theme-toggle:hover {
      background-color: #1d4ed8;
    }

    body.dark-mode #theme-toggle {
      background-color: #60a5fa;
    }

    body.dark-mode #theme-toggle:hover {
      background-color: #3b82f6;
    }
    
#content {
    max-width: 900px;
    margin: 2rem;
    padding: 2rem;
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #e0e0e0 transparent;
}

#content::-webkit-scrollbar {
    width: 8px;
}

#content::-webkit-scrollbar-thumb {
    background-color: #e0e0e0;
    border-radius: 4px;
}

h1 {
    font-size: clamp(1.5rem, 5vw, 1.8rem);
    margin: 0 0 1rem;
    text-align: center;
}

p {
    font-size: clamp(0.9rem, 4vw, 1rem);
    margin: 0.5rem 0;
    line-height: 1.5;
}

#txid {
    width: 100%;
    padding: 0.75rem;
    font-size: 1rem;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-sizing: border-box;
    margin-bottom: 0.75rem;
    transition: border-color 0.2s ease;
}

#txid:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

input[type=submit] {
    width: 100%;
    padding: 0.75rem;
    font-size: 1rem;
    font-weight: 500;
    background-color: #2563eb;
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

input[type=submit]:hover {
    background-color: #1d4ed8;
}
    
#output {
    font-size: clamp(1rem, 3.5vw, 1.2rem);
    margin: 1rem 1rem
      position: relative;
  z-index: 1;
  pointer-events: auto;
}

.output-row {
    display: grid;
    grid-template-columns: 200px 1fr;
    padding: 0.2rem 0;
    border-bottom: 1px solid #f0f0f0;
}

.output-label {
    font-weight: 500;
    color: #1a1a1a;
}

.output-value {
    color: #4a4a4a;
    word-break: break-word;
}

.section-title {
    font-weight: 600;
    margin: 1.5rem 0 1rem;
    font-size: 1.25rem;
    color: #1a1a1a;
    border-left: 4px solid #2563eb;
    padding-left: 0.75rem;
}

.stamp-iframe {
    width: 600px;
    height: auto;
    margin: 1rem 0;
    display: block;
  	aspect-ratio: 1/1;
  	image-rendering: pixelated;
    -ms-transform: scale(0.6);
    -moz-transform: scale(0.6);
    -o-transform: scale(0.6);
    -webkit-transform: scale(0.6);
    transform: scale(0.6);
    -ms-transform-origin: 0 0;
    -moz-transform-origin: 0 0;
    -o-transform-origin: 0 0;
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0
  }



.stamp-image {
  	width: 600px;
    height: auto;
    margin: 1rem 0;
    display: block;
    image-rendering: pixelated;
    -ms-transform: scale(0.5);
    -moz-transform: scale(0.5);
    -o-transform: scale(0.5);
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    -ms-transform-origin: 0 0;
    -moz-transform-origin: 0 0;
    -o-transform-origin: 0 0;
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0;  
    
}

    .stamp-video {
      width: 600px;
      height: auto;
          -ms-transform: scale(0.5);
    -moz-transform: scale(0.5);
    -o-transform: scale(0.5);
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    -ms-transform-origin: 0 0;
    -moz-transform-origin: 0 0;
    -o-transform-origin: 0 0;
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0
      transform-origin: top left;
      margin: 0;
    }
    
details {
    cursor: pointer;
    margin: 0.75rem 0;
}

summary {
    font-size: clamp(1rem, 3.5vw, 1.2rem);
}

pre {
    font-size: 0.875rem;
    margin: 0.75rem 0;
    padding: 1rem;
    background-color: #f8fafc;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    white-space: pre-wrap;
    overflow-x: auto;
}

pre.base64-content {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}

#output2 a {
    font-size: 0.875rem;
    color: #2563eb;
    text-decoration: none;
    margin-right: 1rem;
    transition: color 0.2s ease;
}

#output2 a:hover {
    color: #1d4ed8;
    text-decoration: underline;
}

#footer {
    font-size: 0.875rem;
    text-align: center;
    margin-top: 3rem;
    color: #6b7280;
}

    #content {
      position: relative; /* Ensure button is positioned relative to content */
    }
    
    
@media (max-width: 600px) {
    #content {
        margin: 1rem;
        padding: 1.5rem;
    }

    h1 {
        font-size: 1.5rem;
    }

    p {
        font-size: 0.875rem;
    }

    #output {
        font-size: 0.875rem;
    }

    .output-row {
        grid-template-columns: 120px 1fr;
        gap: 0.5rem;
    }

    .section-title {
        font-size: 1.125rem;
    }

    summary {
        font-size: 0.875rem;
    }

    pre {
        font-size: 0.75rem;
        padding: 0.75rem;
    }

}
  </style>
</head>
<body>
<div id="content">
    <button id="theme-toggle" onclick="toggleDarkMode()"> Dark Mode</button>
  <h1>Bitcoin STAMP <br> Decoder v1.0</h1><Br>
  <p>Enter a Bitcoin transaction ID to decode CP/Stamps Data.</p>
  <form onsubmit="event.preventDefault(); get_json(document.getElementById('txid').value);">
    <p>
      <input type="text" id="txid" name="txid" placeholder="Enter Bitcoin transaction ID" aria-label="Bitcoin transaction ID">
      <input type="submit" value="Submit">
    </p><br>
  </form>
  <p>This Stamp decoder is a remix of JPs Counterparty Decoderit raids the BlockCypher API, grabs transaction goodies, and pulls out STAMP data like a blockchain treasure hunter.</p> <br>
  <p><b>Note:</b> Now supports PNG, GIF, SVG+XML, WebP, and limited TEXT/HTMLClassic and Olga STAMPs included, no MIME left behind.</p>
  <pre>
 ____ ___ _____ ____ ___ ___ _   _        
| __ )_ _|_   _/ ___/ _ \_ _| \ | |      
|  _ \| |  | || |  | | | | ||  \| |      
| |_) | |  | || |__| |_| | || |\  |    
|____/___| |_| \____\___/___|_| \_|    
 
 ____ _____  _    __  __ ____  ____
/ ___|_   _|/ \  |  \/  |  _ \/ ___| 
\___ \ | | / _ \ | |\/| | |_) \___ \ 
 ___) || |/ ___ \| |  | |  __/ ___) |
|____/ |_/_/   \_\_|  |_|_|   |____/ 
  </pre>
  <div id="output"></div>
  <div id="output2"></div>
  <div id="footer">
    <p><i>Original Counterparty Decoder from JP<br>
    For more info, read <a href="https://jpjanssen.com/how-to-reverse-engineer-counterparty-txs/">blog post</a>.</i><br><br>
    Donate BTC, STAMP or SRC20 Tokens:<br>
      NSID Wallet (TBD)</p>
  </div>
</div>
</body>
</html>